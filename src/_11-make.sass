@use "10-variables" as *

/// Creates a namespaced class name - for example 'fred' becomes 'bf-fred'.
///
/// @param {string} $class
///     Class name.
/// @return {string}
///     Namespaced class name.
@function -get-class-name($class)
    @if str-slice($class, 1, 2) == $bf-prefix
        @return $class
    @else
        @return $bf-prefix + $bf-separator + $class



/// Creates a namespaced sub-class name - for example 'fred' 'jones' becomes 'bf-fred-jones'.
///
/// @param {string} $base-class
///     Base class name.
/// @param {string} $sub-class
///     Sub class name.
/// @return {string}
///     Namespaced sub-class name.
@function -get-sub-class-name($base-class, $sub-class)
    @return -get-class-name($base-class) + $bf-separator + $sub-class



/// Returns value or default if value is false / null.
///
/// @param {string} $value
///     Value to check.
/// @param {string} $default
///     Default vaule.
/// @return {string}
///     Value or default if value is false / null.
@function -get-value($value, $default)
    @return if($value, $value, $default)



@function -is-map($var)
    @return type-of($var) == "map"



/// Outputs a single namespaced class definition.
///
/// @param {string} $class
///     Class name.
@mixin single($class)
    %#{-get-class-name($class)}
        @content



/// Outputs responsive namespaced class definitions.
/// $base-class is the base class name, $sub-class-map contains sub-class names and optional values.
/// Each sub-class gets the standard breakpoints added as a suffix.
///
/// @param {string} $base-class
///     Base class name.
/// @param {map} $sub-class-map
///     Map of class definitions, e.g. (25: 25%, 50: 50%, auto: auto).
///     If the value is null, the key will be passed to the @content block instead, e.g. (red, blue)
@mixin responsive($base-class, $sub-class-map)
    // output the base definition first
    @each $sub-class, $property-value in $sub-class-map
        $class: -get-sub-class-name($base-class, $sub-class)
        $value: -get-value($property-value, $sub-class)
        @if -is-map($value)
            @include responsive($class, $value) using ($recursive-value)
                @content($recursive-value)
        @else
            %#{$class}
                @content($value)
            @if $bf-debug
                @debug $class
    
    // loop separately to ensure min-width overrides come AFTER the base definition
    @each $sub-class, $property-value in $sub-class-map
        $value: -get-value($property-value, $sub-class)
        @if not -is-map($value)
            @include -up() using ($breakpoint)
                $class: -get-sub-class-name($base-class, $sub-class) + $bf-separator + $breakpoint
                %#{$class}
                    @content($value)
                @if $bf-debug
                    @debug $class



/// Outputs minimum width (breakpoint) definitions.
///
/// @param {string} $property-map
///     Map of CSS definitions, e.g. (sm: 150px, md: 200px, lg: 250px).
@mixin up($property-map...)
    @include -up() using ($breakpoint)
        &#{$bf-separator + $breakpoint}
            @each $property-name, $property-values in $property-map
                #{$property-name}: map-get($property-values, $breakpoint)



/// Loops through breakpoints and calls @content for each one, passing the breakpoint key.
@mixin -up()
    @each $breakpoint-key, $breakpoint-value in $bf-breakpoints
        @media (min-width: $breakpoint-value)
            @content($breakpoint-key)
